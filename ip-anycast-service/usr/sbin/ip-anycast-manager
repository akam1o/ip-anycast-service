#!/bin/bash
set -euo pipefail

# Paths
CONFIG_FILE="/etc/ip-anycast/ip-anycast.conf"
TEMPLATE_FILE="/etc/ip-anycast/bird.template"
BIRD_CONF="/etc/bird/bird.conf"

warn() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [ip-anycast] WARNING: $1" >&2
}

# 1. Load Configuration
if [ ! -f "$CONFIG_FILE" ]; then
    echo "Error: Config file $CONFIG_FILE not found."
    exit 1
fi

# Refuse to source an unsafe config file (ownership/perms).
if command -v stat >/dev/null 2>&1; then
    owner="$(stat -c '%U' "$CONFIG_FILE" 2>/dev/null || true)"
    perms="$(stat -c '%a' "$CONFIG_FILE" 2>/dev/null || true)"
    if [ -n "$owner" ] && [ "$owner" != "root" ]; then
        echo "Error: Refusing to load $CONFIG_FILE (owner is '$owner', expected 'root')." >&2
        exit 1
    fi
    if [ -n "$perms" ]; then
        group_write=$(( (10#$perms / 10) % 10 ))
        other_write=$(( 10#$perms % 10 ))
        if [ $((group_write & 2)) -ne 0 ] || [ $((other_write & 2)) -ne 0 ]; then
            echo "Error: Refusing to load $CONFIG_FILE (writable by group/others: mode $perms)." >&2
            exit 1
        fi
    fi
else
    warn "stat not found; skipping config permission checks."
fi

source "$CONFIG_FILE"

# Logging helper
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [ip-anycast] $1"
}

require_var() {
    local name="$1"
    local value="${!name-}"
    if [ -z "${value}" ]; then
        echo "Error: Required config '$name' is missing or empty in $CONFIG_FILE." >&2
        exit 1
    fi
}

# Optional settings (can be overridden in config)
HEALTHCHECK_TIMEOUT_SECONDS="${HEALTHCHECK_TIMEOUT_SECONDS:-2}"
HEALTHCHECK_INTERVAL_SECONDS="${HEALTHCHECK_INTERVAL_SECONDS:-5}"

require_var "APP_TYPE"
require_var "ANYCAST_CIDR"
require_var "INTERFACE_NAME"
require_var "ROUTER_ID"
require_var "LOCAL_AS"
require_var "SOURCE_IP"
require_var "NEIGHBORS"
require_var "BFD_INTERVAL"
require_var "BFD_IDLE_TX"
require_var "BFD_MULTIPLIER"

escape_sed_replacement() {
    # Escape backslash, &, and the delimiter (|)
    printf '%s' "$1" | sed -e 's/\\/\\\\/g' -e 's/&/\\&/g' -e 's/|/\\|/g'
}

# 2. Network Setup Function
setup_interface() {
    log "Setting up interface $INTERFACE_NAME..."
    
    # Remove existing interface to ensure a clean state
    if ip link show "$INTERFACE_NAME" > /dev/null 2>&1; then
        ip link del "$INTERFACE_NAME"
    fi
    
    # Create dummy interface and assign IP
    ip link add name "$INTERFACE_NAME" type dummy
    ip addr add "$ANYCAST_CIDR" dev "$INTERFACE_NAME"
    
    # IMPORTANT: Initialize state as DOWN to prevent premature advertisement
    ip link set "$INTERFACE_NAME" down
}

# 3. Generate BIRD Config Function
generate_bird_config() {
    log "Generating $BIRD_CONF from template..."
    
    # Dynamically build the neighbor configuration block
    NEIGHBOR_BLOCK=""
    count=0
    for neighbor in $NEIGHBORS; do
        neigh_ip=$(echo "$neighbor" | cut -d: -f1)
        neigh_as=$(echo "$neighbor" | cut -d: -f2)
        
        # Validate that IP and AS are not empty
        if [[ -z "$neigh_ip" || -z "$neigh_as" ]]; then
            log "Warning: Invalid neighbor format '$neighbor'. Skipping."
            continue
        fi

        NEIGHBOR_BLOCK+="protocol bgp upstream_$count from bgp_template { neighbor $neigh_ip as $neigh_as; }\n"
        count=$((count+1))
    done

    # Create a temporary config file
    cp "$TEMPLATE_FILE" "$BIRD_CONF.tmp"

    # Replace basic placeholders
    sed -i "s|__ROUTER_ID__|$(escape_sed_replacement "$ROUTER_ID")|g"           "$BIRD_CONF.tmp"
    sed -i "s|__ANYCAST_CIDR__|$(escape_sed_replacement "$ANYCAST_CIDR")|g"     "$BIRD_CONF.tmp"
    sed -i "s|__INTERFACE_NAME__|$(escape_sed_replacement "$INTERFACE_NAME")|g" "$BIRD_CONF.tmp"
    sed -i "s|__LOCAL_AS__|$(escape_sed_replacement "$LOCAL_AS")|g"             "$BIRD_CONF.tmp"
    sed -i "s|__SOURCE_IP__|$(escape_sed_replacement "$SOURCE_IP")|g"           "$BIRD_CONF.tmp"
    
    # Replace BFD placeholders
    sed -i "s|__BFD_INTERVAL__|$(escape_sed_replacement "$BFD_INTERVAL")|g"     "$BIRD_CONF.tmp"
    sed -i "s|__BFD_IDLE_TX__|$(escape_sed_replacement "$BFD_IDLE_TX")|g"       "$BIRD_CONF.tmp"
    sed -i "s|__BFD_MULTIPLIER__|$(escape_sed_replacement "$BFD_MULTIPLIER")|g" "$BIRD_CONF.tmp"
    
    # Insert Neighbor block (remove placeholder and append block)
    sed -i "s|__NEIGHBOR_CONFIG__||g" "$BIRD_CONF.tmp"
    echo -e "$NEIGHBOR_BLOCK" >> "$BIRD_CONF.tmp"

    # Apply the new configuration
    mv "$BIRD_CONF.tmp" "$BIRD_CONF"
}

reload_bird() {
    log "Applying BIRD configuration..."

    if systemctl is-active --quiet bird; then
        if command -v birdc >/dev/null 2>&1; then
            if birdc configure >/dev/null 2>&1; then
                log "BIRD reloaded via 'birdc configure'."
                return 0
            fi
            warn "'birdc configure' failed; falling back to systemd reload/restart."
        fi

        if systemctl reload bird >/dev/null 2>&1; then
            log "BIRD reloaded via 'systemctl reload bird'."
            return 0
        fi

        warn "'systemctl reload bird' failed; restarting bird."
        systemctl restart bird
        return 0
    fi

    log "BIRD is not active; starting bird."
    systemctl start bird
}

# 4. Health Check Function
check_health() {
    case "$APP_TYPE" in
        "http")
            # Check HTTP connection to localhost
            curl -s -f --connect-timeout "$HEALTHCHECK_TIMEOUT_SECONDS" --max-time "$HEALTHCHECK_TIMEOUT_SECONDS" -o /dev/null http://127.0.0.1
            ;;
        "https")
            # Check HTTPS connection to localhost (ignoring cert errors)
            curl -k -s -f --connect-timeout "$HEALTHCHECK_TIMEOUT_SECONDS" --max-time "$HEALTHCHECK_TIMEOUT_SECONDS" -o /dev/null https://127.0.0.1
            ;;
        "ntp")
            # Check if chrony is synchronized and offset is acceptable (< 100ms)
            chronyc tracking > /dev/null 2>&1 && \
            chronyc -c tracking | awk -F, '{if ($5 < 0.1 && $5 > -0.1) exit 0; else exit 1}'
            ;;
        "dns")
            # Check if DNS responds to a query for root
            dig +short +time=2 +tries=1 @127.0.0.1 . > /dev/null 2>&1
            ;;
        "ldap")
            # Check TCP connection to LDAP port 389
            nc -z -w 2 127.0.0.1 389
            ;;
        "custom")
            if [ -n "${CUSTOM_CHECK_CMD:-}" ]; then
                if [ ! -x "$CUSTOM_CHECK_CMD" ]; then
                    log "Error: CUSTOM_CHECK_CMD is not executable: $CUSTOM_CHECK_CMD"
                    return 1
                fi
                "$CUSTOM_CHECK_CMD"
            else
                log "Error: Custom check selected but CUSTOM_CHECK_CMD is empty."
                return 1
            fi
            ;;
        *)
            log "Error: Unknown APP_TYPE: $APP_TYPE"
            return 1
            ;;
    esac
}

# --- Main Execution Logic ---

# Cleanup function to remove interface on service stop
cleanup() {
    log "Stopping service. Removing interface $INTERFACE_NAME..."
    ip link set "$INTERFACE_NAME" down 2>/dev/null
    ip link del "$INTERFACE_NAME" 2>/dev/null
    exit 0
}
trap cleanup SIGINT SIGTERM

# Initialize
setup_interface
generate_bird_config

reload_bird
# Wait briefly to ensure BIRD has applied config
sleep 2

log "Starting health check loop for APP_TYPE: $APP_TYPE"

# Loop
while true; do
    # Check current interface state
    IS_UP=$(ip link show "$INTERFACE_NAME" | grep -q "UP" && echo "yes" || echo "no")
    
    if check_health; then
        # Application is HEALTHY
        if [ "$IS_UP" == "no" ]; then
            log "Health check PASSED. Bringing UP $INTERFACE_NAME (Advertise)."
            ip link set "$INTERFACE_NAME" up
        fi
    else
        # Application is UNHEALTHY
        if [ "$IS_UP" == "yes" ]; then
            log "Health check FAILED. Bringing DOWN $INTERFACE_NAME (Withdraw)."
            ip link set "$INTERFACE_NAME" down
        fi
    fi
    
    sleep "$HEALTHCHECK_INTERVAL_SECONDS"
done
